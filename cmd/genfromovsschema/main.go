package main

import (
	"encoding/json"
	"flag"
	"io/ioutil"
	"log"
	"os"
	"path"
	"strings"
	"text/template"

	"github.com/ebay/libovsdb"
)

const TEMPLATE = `
/* THIS CODE WAS AUTOGENERATED BY GENFRONSCHEMA */
/* DO NOT EDIT */

package {{ .Package }}

import (
	"fmt"
	"reflect"
)

const (
    {{ .StructName}}TableName = "{{ .TableName }}"
)
type {{ .StructName }} struct {
    UUID string
{{ range .StructElements }} {{.FieldName}} {{.FieldType}}
{{end}}}

func (odbi *ovndb) rowTo{{.StructName}}(uuid string) (*{{.StructName}}, error) {
	s := &{{.StructName}}{
		UUID:       uuid,
    }
    cache, ok := odbi.cache[{{.StructName}}TableName][uuid]
    if !ok {
        return s, fmt.Errorf("object does not exist in cache")
    }
    sPtr := reflect.ValueOf(s)
	if sPtr.Type().Kind() != reflect.Ptr {
		return s, fmt.Errorf("not a struct ptr")
	}
    obj := reflect.Indirect(sPtr)
{{ range .StructElements }}
	if v, ok := cache.Fields["{{.ColumnName}}"]; ok {
		err := odbi.colToField("{{.ColumnName}}", v, obj.FieldByName("{{.FieldName}}"))
		if err != nil {
			return s, err
		}
	}
{{end}}    
	return s, nil
}

// TODO: Implement Add/Delete functions and the inverse of rowToX
`

func main() {
	flag.Parse()
	log.SetFlags(0)

	f := flag.Arg(0)

	if f == "" {
		log.Fatal("need to specify a path to an ovsschema file")
	}

	schemaFile, err := os.Open(f)
	if err != nil {
		log.Fatal(err)
	}
	defer schemaFile.Close()

	schemaBytes, err := ioutil.ReadAll(schemaFile)
	if err != nil {
		log.Fatal(err)
	}

	var schema libovsdb.DatabaseSchema
	if err := json.Unmarshal(schemaBytes, &schema); err != nil {
		log.Fatal(err)
	}

	pkg := strings.ToLower(schema.Name)

	if err := os.MkdirAll(path.Join(pkg), 0755); err != nil {
		log.Fatal(err)
	}

	t := template.Must(template.New("table").Parse(TEMPLATE))

	for k, v := range schema.Tables {
		td := TableData{
			Package:    pkg,
			TableName:  k,
			StructName: stringToStructName(k),
		}
		elements := []StructElements{}
		for colName, colData := range v.Columns {
			colType := libovsdb.NativeType(colData)
			e := StructElements{
				ColumnName: colName,
				FieldName:  stringToFieldName(colName),
				FieldType:  colType.String(),
			}
			elements = append(elements, e)
		}
		td.StructElements = elements
		f, err := os.Create(path.Join(pkg, strings.ToLower(k+".go")))
		if err != nil {
			log.Fatal(err)
		}
		defer f.Close()
		err = t.Execute(f, td)
		if err != nil {
			log.Fatal(err)
		}
	}
}

type TableData struct {
	Package        string
	TableName      string
	StructName     string
	StructElements []StructElements
}

type StructElements struct {
	ColumnName string
	FieldName  string
	FieldType  string
}

func stringToFieldName(name string) string {
	s := strings.ToLower(name)
	parts := strings.Split(name, "_")
	if len(parts) > 1 {
		s = ""
		for _, p := range parts {
			s += strings.Title(p)
		}
	} else {
		s = strings.Title(s)
	}
	return s
}

func stringToStructName(name string) string {
	s := name
	parts := strings.Split(name, "_")
	if len(parts) > 1 {
		s = ""
		for _, p := range parts {
			s += strings.Title(p)
		}
	} else {
		s = strings.Title(s)
	}
	return s
}
